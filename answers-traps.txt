1. 寄存器 a0 - a7 包含函数的参数，这是我们在 syscall 实验中就已经知道的。寄存器 a2 保存了 13。
2. main 函数中对 f、g 函数的调用被编译器优化成内联函数了，这是一种**取消了函数的参数压栈，减少了调用的开销**的编译器的优化方法。在这里 `f(8)+1` 应该是直接被编译器算出 12 的结果了，就免去了调用函数的过程。不过很明显像是 printf 和 exit 这样的函数就不一样了。
3. 函数 `printf` 位于 0x630。
4. `jalr offset(ra)`，ra 存储下一条汇编语句的地址，那么在这里就是 0x38。（jalr 格式不一样就不在这里细谈了）
5. 输出是 “HE110 World”。
- 57616 按照 16 进制转换为 e110，这个不需要进行更改；
- rld：其 ASCII 码是 72、6c、64（16 进制）；如果要显示 r l d 的话，那么在内存中的布局就应该是 72 6c 64 00。
  - 如果使用小端的话，那么内存中的存储的方式应该是低字节的数据存在低地址，那么就应该写实际字节的写法就是 0x00646c72，这和题目相符；
  - 如果使用大端的话，那么内存中的存储的方式应该是低字节的数据存在高地址，那么就应该写实际字节的写法就是 0x726c6400。
> 大端小端的问题容易弄混的地方是：内存从左到右是地址变大，而我们说的数据的字节是从右到左越来越 “高” 位。实际上大端模式是和我们阅读的习惯一致的。
6. 打印 5223。答案确实不是一个特定的值（虽然重新运行、重新编译都不会导致结果不同）。推测是打印出了 a2 寄存器的值，所以实际上应该是一个相当随机的数。
